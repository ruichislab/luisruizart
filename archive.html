<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>luisruiz.art - Interactive Net Art</title>
    <link rel="stylesheet" href="css/style.css">
    <style>
        /* Back Button */
        #back-to-nexus {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 20000;
            color: #00ffff;
            font-family: 'Courier New', Courier, monospace;
            text-decoration: none;
            border: 1px solid #00ffff;
            padding: 10px 20px;
            background: rgba(0,0,0,0.5);
            transition: all 0.3s ease;
            pointer-events: all;
            cursor: pointer;
            mix-blend-mode: difference;
        }

        #back-to-nexus:hover {
            background: #00ffff;
            color: #000;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            cursor: none;
        }

        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: #0a0e27;
            font-family: Arial, sans-serif;
        }

        /* Custom cursor */
        .custom-cursor {
            position: fixed;
            width: 20px;
            height: 20px;
            border: 2px solid rgba(0, 255, 255, 0.8);
            border-radius: 50%;
            pointer-events: none;
            z-index: 10000;
            transition: transform 0.1s ease, border-color 0.2s ease;
            mix-blend-mode: difference;
        }

        .custom-cursor.active {
            transform: scale(1.5);
            border-color: rgba(255, 0, 255, 1);
        }

        /* Room container */
        .room {
            position: absolute;
            width: 100%;
            height: 100%;
            opacity: 0;
            pointer-events: none;
            transition: opacity 1s ease;
        }

        .room.active {
            opacity: 1;
            pointer-events: all;
        }

        /* Portal navigation system */
        .portals {
            position: absolute;
            width: 100%;
            height: 100%;
            z-index: 100;
            pointer-events: none;
        }

        .portal {
            position: absolute;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(0, 255, 255, 0.3), transparent);
            border: 2px solid rgba(0, 255, 255, 0.2);
            pointer-events: all;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        }

        .portal:hover {
            transform: scale(1.3);
            box-shadow: 0 0 40px rgba(0, 255, 255, 0.8);
            border-color: rgba(0, 255, 255, 0.8);
            background: radial-gradient(circle, rgba(0, 255, 255, 0.5), transparent);
        }

        .portal::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: rgba(0, 255, 255, 0.6);
            animation: portalPulse 2s ease-in-out infinite;
        }

        .portal.visited::before {
            background: rgba(255, 100, 200, 0.6);
        }

        .portal.visited {
            border-color: rgba(255, 100, 200, 0.3);
            background: radial-gradient(circle, rgba(255, 100, 200, 0.2), transparent);
        }

        .portal.visited:hover {
            box-shadow: 0 0 40px rgba(255, 100, 200, 0.8);
            border-color: rgba(255, 100, 200, 0.8);
        }

        @keyframes portalPulse {
            0%, 100% { transform: translate(-50%, -50%) scale(0.8); opacity: 0.6; }
            50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
        }

        /* Portal positions - distributed around edges */
        .portal-1 { top: 10%; left: 5%; }
        .portal-2 { top: 10%; right: 5%; }
        .portal-3 { bottom: 10%; left: 5%; }
        .portal-4 { bottom: 10%; right: 5%; }
        .portal-5 { top: 50%; left: 2%; transform: translateY(-50%); }
        .portal-6 { top: 50%; right: 2%; transform: translateY(-50%); }
        .portal-7 { top: 2%; left: 30%; }
        .portal-8 { top: 2%; left: 70%; }
        .portal-9 { bottom: 2%; left: 30%; }
        .portal-10 { bottom: 2%; left: 70%; }

        /* Room 1: Digital Consciousness */
        #consciousness {
            background: radial-gradient(ellipse at center, #0a0e27 0%, #000814 100%);
        }

        #consciousness canvas {
            width: 100%;
            height: 100%;
        }

        /* Room 2: Harmonic Resonance */
        #harmonic {
            background: #000814;
        }

        #harmonic canvas {
            width: 100%;
            height: 100%;
        }

        /* Room 3: Temporal Flux */
        #temporal {
            background: linear-gradient(135deg, #0a0e27 0%, #1a0b2e 100%);
        }

        #temporal canvas {
            width: 100%;
            height: 100%;
        }

        /* Room 4: Mirror Consciousness */
        #mirror {
            background: #0a0e27;
        }

        #mirror canvas {
            width: 100%;
            height: 100%;
        }

        .clear-button {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(100, 255, 100, 0.2), transparent);
            border: 2px solid rgba(100, 255, 100, 0.3);
            pointer-events: all;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 0 30px rgba(100, 255, 100, 0.4);
            opacity: 0.5;
        }

        .clear-button:hover {
            transform: translate(-50%, -50%) scale(1.2);
            opacity: 1;
            box-shadow: 0 0 60px rgba(100, 255, 100, 0.8);
        }

        /* Room 5: Collective Emergence */
        #emergence {
            background: radial-gradient(circle at 30% 40%, #0a0e27 0%, #000814 100%);
        }

        #emergence canvas {
            width: 100%;
            height: 100%;
        }

        /* Room 6: Void Navigation */
        #void {
            background: #000000;
        }

        #void canvas {
            width: 100%;
            height: 100%;
        }

        /* Room 7: Chromatic Dissolution */
        #chromatic {
            background: #000814;
        }

        #chromatic canvas {
            width: 100%;
            height: 100%;
        }

        /* Room 8: Neural Pathways */
        #neural {
            background: #000000;
        }

        #neural canvas {
            width: 100%;
            height: 100%;
        }

        /* Room 9: Quantum Entanglement */
        #quantum {
            background: #000814;
        }

        #quantum canvas {
            width: 100%;
            height: 100%;
        }

        /* Room 10: Fractal Recursion */
        #fractal {
            background: radial-gradient(ellipse at center, #320050 0%, #000000 100%);
        }

        #fractal canvas {
            width: 100%;
            height: 100%;
        }

        /* Room 11: Crystalline Growth */
        #crystal {
            background: radial-gradient(circle at 50% 50%, #0a1e2e 0%, #000814 100%);
        }

        #crystal canvas {
            width: 100%;
            height: 100%;
        }

        /* Room 12: Luminous Echo */
        #luminous {
            background: #000814;
        }

        #luminous canvas {
            width: 100%;
            height: 100%;
        }

        /* Room 13: Atmospheric Pressure */
        #atmospheric {
            background: #0a0e27;
        }

        #atmospheric canvas {
            width: 100%;
            height: 100%;
        }

        /* Room 14: Dimensional Breach */
        #dimensional {
            background: #000000;
        }

        #dimensional canvas {
            width: 100%;
            height: 100%;
        }

        /* Room 15: Synaptic Storm */
        #synaptic {
            background: #000000;
        }

        #synaptic canvas {
            width: 100%;
            height: 100%;
        }

        /* Room 16: Void Communion */
        #voidcomm {
            background: #141428;
        }

        #voidcomm canvas {
            width: 100%;
            height: 100%;
        }

        /* Room 17: Metamorphic Flux */
        #metamorphic {
            background: #0a0e27;
        }

        #metamorphic canvas {
            width: 100%;
            height: 100%;
        }

        /* Room 18: Digital Decay */
        #decay {
            background: #0a0a0a;
        }

        #decay canvas {
            width: 100%;
            height: 100%;
        }

        /* Room 19: Emergence Protocol */
        #protocol {
            background: #000814;
        }

        #protocol canvas {
            width: 100%;
            height: 100%;
        }

        /* Room 20: Infinite Recursion */
        #infinite {
            background: radial-gradient(ellipse at center, #320050 0%, #000000 100%);
        }

        #infinite canvas {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <!-- Custom cursor -->
    <div class="custom-cursor"></div>

    <!-- Room 1: Digital Consciousness -->
    <div id="consciousness" class="room active">
        <canvas id="consciousness-canvas"></canvas>
        <div class="portals">
            <div class="portal portal-1" data-room="harmonic"></div>
            <div class="portal portal-2" data-room="temporal"></div>
            <div class="portal portal-3" data-room="mirror"></div>
            <div class="portal portal-4" data-room="emergence"></div>
        </div>
    </div>

    <!-- Room 2: Harmonic Resonance -->
    <div id="harmonic" class="room">
        <canvas id="harmonic-canvas"></canvas>
        <div class="portals">
            <div class="portal portal-1" data-room="consciousness"></div>
            <div class="portal portal-2" data-room="temporal"></div>
            <div class="portal portal-3" data-room="mirror"></div>
            <div class="portal portal-4" data-room="emergence"></div>
        </div>
    </div>

    <!-- Room 3: Temporal Flux -->
    <div id="temporal" class="room">
        <canvas id="temporal-canvas"></canvas>
        <div class="portals">
            <div class="portal portal-1" data-room="consciousness"></div>
            <div class="portal portal-2" data-room="harmonic"></div>
            <div class="portal portal-3" data-room="mirror"></div>
            <div class="portal portal-4" data-room="emergence"></div>
        </div>
    </div>

    <!-- Room 4: Mirror Consciousness -->
    <div id="mirror" class="room">
        <canvas id="mirror-canvas"></canvas>
        <div class="clear-button" id="mirror-clear"></div>
        <div class="portals">
            <div class="portal portal-1" data-room="consciousness"></div>
            <div class="portal portal-2" data-room="harmonic"></div>
            <div class="portal portal-3" data-room="temporal"></div>
            <div class="portal portal-4" data-room="emergence"></div>
        </div>
    </div>

    <!-- Room 5: Collective Emergence -->
    <div id="emergence" class="room">
        <canvas id="emergence-canvas"></canvas>
        <div class="portals">
            <div class="portal portal-1" data-room="consciousness"></div>
            <div class="portal portal-2" data-room="harmonic"></div>
            <div class="portal portal-3" data-room="temporal"></div>
            <div class="portal portal-4" data-room="mirror"></div>
            <div class="portal portal-5" data-room="void"></div>
        </div>
    </div>

    <!-- Room 6: Void Navigation -->
    <div id="void" class="room">
        <canvas id="void-canvas"></canvas>
        <div class="portals">
            <div class="portal portal-1" data-room="emergence"></div>
            <div class="portal portal-2" data-room="chromatic"></div>
            <div class="portal portal-3" data-room="neural"></div>
            <div class="portal portal-4" data-room="quantum"></div>
        </div>
    </div>

    <!-- Room 7: Chromatic Dissolution -->
    <div id="chromatic" class="room">
        <canvas id="chromatic-canvas"></canvas>
        <div class="portals">
            <div class="portal portal-1" data-room="void"></div>
            <div class="portal portal-2" data-room="neural"></div>
            <div class="portal portal-3" data-room="quantum"></div>
            <div class="portal portal-4" data-room="fractal"></div>
        </div>
    </div>

    <!-- Room 8: Neural Pathways -->
    <div id="neural" class="room">
        <canvas id="neural-canvas"></canvas>
        <div class="portals">
            <div class="portal portal-1" data-room="void"></div>
            <div class="portal portal-2" data-room="chromatic"></div>
            <div class="portal portal-3" data-room="quantum"></div>
            <div class="portal portal-4" data-room="fractal"></div>
        </div>
    </div>

    <!-- Room 9: Quantum Entanglement -->
    <div id="quantum" class="room">
        <canvas id="quantum-canvas"></canvas>
        <div class="portals">
            <div class="portal portal-1" data-room="neural"></div>
            <div class="portal portal-2" data-room="chromatic"></div>
            <div class="portal portal-3" data-room="fractal"></div>
            <div class="portal portal-4" data-room="crystal"></div>
        </div>
    </div>

    <!-- Room 10: Fractal Recursion -->
    <div id="fractal" class="room">
        <canvas id="fractal-canvas"></canvas>
        <div class="portals">
            <div class="portal portal-1" data-room="quantum"></div>
            <div class="portal portal-2" data-room="crystal"></div>
            <div class="portal portal-3" data-room="luminous"></div>
            <div class="portal portal-4" data-room="atmospheric"></div>
        </div>
    </div>

    <!-- Room 11: Crystalline Growth -->
    <div id="crystal" class="room">
        <canvas id="crystal-canvas"></canvas>
        <div class="portals">
            <div class="portal portal-1" data-room="fractal"></div>
            <div class="portal portal-2" data-room="luminous"></div>
            <div class="portal portal-3" data-room="atmospheric"></div>
            <div class="portal portal-4" data-room="dimensional"></div>
        </div>
    </div>

    <!-- Room 12: Luminous Echo -->
    <div id="luminous" class="room">
        <canvas id="luminous-canvas"></canvas>
        <div class="portals">
            <div class="portal portal-1" data-room="crystal"></div>
            <div class="portal portal-2" data-room="atmospheric"></div>
            <div class="portal portal-3" data-room="dimensional"></div>
            <div class="portal portal-4" data-room="synaptic"></div>
        </div>
    </div>

    <!-- Room 13: Atmospheric Pressure -->
    <div id="atmospheric" class="room">
        <canvas id="atmospheric-canvas"></canvas>
        <div class="portals">
            <div class="portal portal-1" data-room="luminous"></div>
            <div class="portal portal-2" data-room="dimensional"></div>
            <div class="portal portal-3" data-room="synaptic"></div>
            <div class="portal portal-4" data-room="voidcomm"></div>
        </div>
    </div>

    <!-- Room 14: Dimensional Breach -->
    <div id="dimensional" class="room">
        <canvas id="dimensional-canvas"></canvas>
        <div class="portals">
            <div class="portal portal-1" data-room="atmospheric"></div>
            <div class="portal portal-2" data-room="synaptic"></div>
            <div class="portal portal-3" data-room="voidcomm"></div>
            <div class="portal portal-4" data-room="metamorphic"></div>
        </div>
    </div>

    <!-- Room 15: Synaptic Storm -->
    <div id="synaptic" class="room">
        <canvas id="synaptic-canvas"></canvas>
        <div class="portals">
            <div class="portal portal-1" data-room="dimensional"></div>
            <div class="portal portal-2" data-room="voidcomm"></div>
            <div class="portal portal-3" data-room="metamorphic"></div>
            <div class="portal portal-4" data-room="decay"></div>
        </div>
    </div>

    <!-- Room 16: Void Communion -->
    <div id="voidcomm" class="room">
        <canvas id="voidcomm-canvas"></canvas>
        <div class="portals">
            <div class="portal portal-1" data-room="synaptic"></div>
            <div class="portal portal-2" data-room="metamorphic"></div>
            <div class="portal portal-3" data-room="decay"></div>
            <div class="portal portal-4" data-room="protocol"></div>
        </div>
    </div>

    <!-- Room 17: Metamorphic Flux -->
    <div id="metamorphic" class="room">
        <canvas id="metamorphic-canvas"></canvas>
        <div class="portals">
            <div class="portal portal-1" data-room="voidcomm"></div>
            <div class="portal portal-2" data-room="decay"></div>
            <div class="portal portal-3" data-room="protocol"></div>
            <div class="portal portal-4" data-room="infinite"></div>
        </div>
    </div>

    <!-- Room 18: Digital Decay -->
    <div id="decay" class="room">
        <canvas id="decay-canvas"></canvas>
        <div class="portals">
            <div class="portal portal-1" data-room="metamorphic"></div>
            <div class="portal portal-2" data-room="protocol"></div>
            <div class="portal portal-3" data-room="infinite"></div>
            <div class="portal portal-4" data-room="consciousness"></div>
        </div>
    </div>

    <!-- Room 19: Emergence Protocol -->
    <div id="protocol" class="room">
        <canvas id="protocol-canvas"></canvas>
        <div class="portals">
            <div class="portal portal-1" data-room="decay"></div>
            <div class="portal portal-2" data-room="infinite"></div>
            <div class="portal portal-3" data-room="consciousness"></div>
            <div class="portal portal-4" data-room="harmonic"></div>
        </div>
    </div>

    <!-- Room 20: Infinite Recursion -->
    <div id="infinite" class="room">
        <canvas id="infinite-canvas"></canvas>
        <div class="portals">
            <div class="portal portal-1" data-room="protocol"></div>
            <div class="portal portal-2" data-room="consciousness"></div>
            <div class="portal portal-3" data-room="temporal"></div>
            <div class="portal portal-4" data-room="fractal"></div>
        </div>
    </div>

    <script>
        // Global variables
        let currentRoom = 'consciousness';
        let mouse = { x: 0, y: 0 };
        let mouseDown = false;
        let visitedRooms = { 'consciousness': true };

        // Custom cursor
        const cursor = document.querySelector('.custom-cursor');
        document.addEventListener('mousemove', (e) => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
            cursor.style.left = e.clientX + 'px';
            cursor.style.top = e.clientY + 'px';
        });

        document.addEventListener('mousedown', () => {
            mouseDown = true;
            cursor.classList.add('active');
        });

        document.addEventListener('mouseup', () => {
            mouseDown = false;
            cursor.classList.remove('active');
        });

        // Room switching
        function switchRoom(roomId) {
            const rooms = document.querySelectorAll('.room');
            rooms.forEach(room => room.classList.remove('active'));
            document.getElementById(roomId).classList.add('active');
            currentRoom = roomId;

            // Mark room as visited
            visitedRooms[roomId] = true;
            updatePortalStyles();
        }

        // Update portal visual states
        function updatePortalStyles() {
            document.querySelectorAll('.portal').forEach(portal => {
                const targetRoom = portal.getAttribute('data-room');
                if (visitedRooms[targetRoom]) {
                    portal.classList.add('visited');
                } else {
                    portal.classList.remove('visited');
                }
            });
        }

        // Portal navigation
        document.querySelectorAll('.portal').forEach(portal => {
            portal.addEventListener('click', (e) => {
                e.stopPropagation();
                const targetRoom = portal.getAttribute('data-room');
                switchRoom(targetRoom);
            });
        });

        // ===== ROOM 1: DIGITAL CONSCIOUSNESS =====
        const consciousnessCanvas = document.getElementById('consciousness-canvas');
        const consciousnessCtx = consciousnessCanvas.getContext('2d');
        consciousnessCanvas.width = window.innerWidth;
        consciousnessCanvas.height = window.innerHeight;

        class Particle {
            constructor() {
                this.x = Math.random() * consciousnessCanvas.width;
                this.y = Math.random() * consciousnessCanvas.height;
                this.vx = (Math.random() - 0.5) * 0.5;
                this.vy = (Math.random() - 0.5) * 0.5;
                this.size = Math.random() * 3 + 2;
                this.color = Math.random() > 0.5 ? 'rgba(0, 255, 255, 0.6)' : 'rgba(138, 43, 226, 0.5)';
                this.trail = [];
            }

            update() {
                // Gravitational attraction to mouse
                const dx = mouse.x - this.x;
                const dy = mouse.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < 300) {
                    const force = (300 - dist) / 300 * 0.05;
                    this.vx += (dx / dist) * force;
                    this.vy += (dy / dist) * force;
                }

                // Apply velocity
                this.x += this.vx;
                this.y += this.vy;

                // Friction
                this.vx *= 0.98;
                this.vy *= 0.98;

                // Wrap around edges
                if (this.x < 0) this.x = consciousnessCanvas.width;
                if (this.x > consciousnessCanvas.width) this.x = 0;
                if (this.y < 0) this.y = consciousnessCanvas.height;
                if (this.y > consciousnessCanvas.height) this.y = 0;

                // Trail management
                this.trail.push({ x: this.x, y: this.y });
                if (this.trail.length > 20) this.trail.shift();
            }

            draw() {
                // Draw trail
                consciousnessCtx.strokeStyle = this.color;
                consciousnessCtx.lineWidth = 1;
                consciousnessCtx.beginPath();
                for (let i = 0; i < this.trail.length; i++) {
                    const point = this.trail[i];
                    if (i === 0) {
                        consciousnessCtx.moveTo(point.x, point.y);
                    } else {
                        consciousnessCtx.lineTo(point.x, point.y);
                    }
                }
                consciousnessCtx.stroke();

                // Draw particle
                consciousnessCtx.fillStyle = this.color;
                consciousnessCtx.shadowBlur = 20;
                consciousnessCtx.shadowColor = this.color;
                consciousnessCtx.beginPath();
                consciousnessCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                consciousnessCtx.fill();
                consciousnessCtx.shadowBlur = 0;
            }
        }

        const particles = [];
        for (let i = 0; i < 80; i++) {
            particles.push(new Particle());
        }

        let pulseWaves = [];

        consciousnessCanvas.addEventListener('click', (e) => {
            if (currentRoom === 'consciousness') {
                pulseWaves.push({
                    x: e.clientX,
                    y: e.clientY,
                    radius: 0,
                    maxRadius: 300,
                    alpha: 1
                });
            }
        });

        function animateConsciousness() {
            if (currentRoom === 'consciousness') {
                consciousnessCtx.fillStyle = 'rgba(10, 14, 39, 0.1)';
                consciousnessCtx.fillRect(0, 0, consciousnessCanvas.width, consciousnessCanvas.height);

                // Update and draw particles
                particles.forEach(particle => {
                    particle.update();
                    particle.draw();
                });

                // Draw pulse waves
                pulseWaves = pulseWaves.filter(wave => wave.alpha > 0);
                pulseWaves.forEach(wave => {
                    wave.radius += 5;
                    wave.alpha -= 0.02;

                    consciousnessCtx.strokeStyle = `rgba(0, 255, 255, ${wave.alpha})`;
                    consciousnessCtx.lineWidth = 3;
                    consciousnessCtx.beginPath();
                    consciousnessCtx.arc(wave.x, wave.y, wave.radius, 0, Math.PI * 2);
                    consciousnessCtx.stroke();

                    // Push particles away
                    particles.forEach(particle => {
                        const dx = particle.x - wave.x;
                        const dy = particle.y - wave.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (Math.abs(dist - wave.radius) < 20) {
                            const force = 0.5;
                            particle.vx += (dx / dist) * force;
                            particle.vy += (dy / dist) * force;
                        }
                    });
                });
            }
            requestAnimationFrame(animateConsciousness);
        }
        animateConsciousness();

        // ===== ROOM 2: HARMONIC RESONANCE =====
        const harmonicCanvas = document.getElementById('harmonic-canvas');
        const harmonicCtx = harmonicCanvas.getContext('2d');
        harmonicCanvas.width = window.innerWidth;
        harmonicCanvas.height = window.innerHeight;

        let circles = [];

        harmonicCanvas.addEventListener('click', (e) => {
            if (currentRoom === 'harmonic') {
                const colors = [
                    'rgba(0, 255, 255, 0.8)',
                    'rgba(255, 0, 127, 0.8)',
                    'rgba(0, 255, 127, 0.8)'
                ];
                const color = colors[Math.floor((e.clientY / harmonicCanvas.height) * colors.length)];

                circles.push({
                    x: e.clientX,
                    y: e.clientY,
                    radius: 0,
                    maxRadius: Math.random() * 200 + 100,
                    color: color,
                    alpha: 1,
                    speed: Math.random() * 2 + 1
                });

                if (circles.length > 100) circles.shift();
            }
        });

        function animateHarmonic() {
            if (currentRoom === 'harmonic') {
                harmonicCtx.fillStyle = 'rgba(0, 8, 20, 0.05)';
                harmonicCtx.fillRect(0, 0, harmonicCanvas.width, harmonicCanvas.height);

                circles = circles.filter(circle => circle.alpha > 0);
                circles.forEach(circle => {
                    circle.radius += circle.speed;
                    circle.alpha -= 0.005;

                    harmonicCtx.strokeStyle = circle.color.replace(/[\d.]+\)$/, circle.alpha + ')');
                    harmonicCtx.lineWidth = 2;
                    harmonicCtx.beginPath();
                    harmonicCtx.arc(circle.x, circle.y, circle.radius, 0, Math.PI * 2);
                    harmonicCtx.stroke();
                });
            }
            requestAnimationFrame(animateHarmonic);
        }
        animateHarmonic();

        // ===== ROOM 3: TEMPORAL FLUX =====
        const temporalCanvas = document.getElementById('temporal-canvas');
        const temporalCtx = temporalCanvas.getContext('2d');
        temporalCanvas.width = window.innerWidth;
        temporalCanvas.height = window.innerHeight;

        let timeScale = 1;

        temporalCanvas.addEventListener('mousemove', (e) => {
            if (currentRoom === 'temporal') {
                const normalizedY = e.clientY / temporalCanvas.height;
                timeScale = 1 - normalizedY * 0.9 + 0.1;
            }
        });

        class TemporalShape {
            constructor() {
                this.x = temporalCanvas.width / 2 + (Math.random() - 0.5) * 400;
                this.y = temporalCanvas.height / 2 + (Math.random() - 0.5) * 400;
                this.size = Math.random() * 100 + 50;
                this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 0.02;
                this.pulsePhase = Math.random() * Math.PI * 2;
                this.type = Math.floor(Math.random() * 3);
                this.color = ['rgba(255, 200, 0, 0.7)', 'rgba(200, 50, 50, 0.7)', 'rgba(50, 50, 50, 0.7)'][this.type];
            }

            update(timeScale) {
                this.rotation += this.rotationSpeed * timeScale;
                this.pulsePhase += 0.05 * timeScale;
            }

            draw() {
                const pulse = Math.sin(this.pulsePhase) * 0.2 + 1;
                const currentSize = this.size * pulse;

                temporalCtx.save();
                temporalCtx.translate(this.x, this.y);
                temporalCtx.rotate(this.rotation);

                temporalCtx.fillStyle = this.color;
                temporalCtx.shadowBlur = 30;
                temporalCtx.shadowColor = this.color;

                if (this.type === 0) {
                    temporalCtx.fillRect(-currentSize / 2, -currentSize / 2, currentSize, currentSize);
                } else if (this.type === 1) {
                    temporalCtx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (Math.PI * 2 / 6) * i;
                        const x = Math.cos(angle) * currentSize / 2;
                        const y = Math.sin(angle) * currentSize / 2;
                        if (i === 0) temporalCtx.moveTo(x, y);
                        else temporalCtx.lineTo(x, y);
                    }
                    temporalCtx.closePath();
                    temporalCtx.fill();
                } else {
                    temporalCtx.beginPath();
                    temporalCtx.arc(0, 0, currentSize / 2, 0, Math.PI * 2);
                    temporalCtx.fill();
                }

                temporalCtx.shadowBlur = 0;
                temporalCtx.restore();
            }
        }

        const temporalShapes = [];
        for (let i = 0; i < 15; i++) {
            temporalShapes.push(new TemporalShape());
        }

        function animateTemporal() {
            if (currentRoom === 'temporal') {
                temporalCtx.fillStyle = 'rgba(10, 14, 39, 0.2)';
                temporalCtx.fillRect(0, 0, temporalCanvas.width, temporalCanvas.height);

                temporalShapes.forEach(shape => {
                    shape.update(timeScale);
                    shape.draw();
                });

                // Draw time indicator
                temporalCtx.fillStyle = `rgba(255, 255, 255, ${timeScale * 0.3})`;
                temporalCtx.fillRect(20, 20, 5, temporalCanvas.height - 40);
                temporalCtx.fillRect(20, 20 + (1 - timeScale) * (temporalCanvas.height - 40), 30, 5);
            }
            requestAnimationFrame(animateTemporal);
        }
        animateTemporal();

        // ===== ROOM 4: MIRROR CONSCIOUSNESS =====
        const mirrorCanvas = document.getElementById('mirror-canvas');
        const mirrorCtx = mirrorCanvas.getContext('2d');
        mirrorCanvas.width = window.innerWidth;
        mirrorCanvas.height = window.innerHeight;

        let mirrorTrails = [];
        let ghostCursors = [];
        let fractalPatterns = [];

        for (let i = 0; i < 5; i++) {
            ghostCursors.push({ x: 0, y: 0, delay: i * 3 });
        }

        mirrorCanvas.addEventListener('mousemove', (e) => {
            if (currentRoom === 'mirror') {
                mirrorTrails.push({
                    x: e.clientX,
                    y: e.clientY,
                    alpha: 1,
                    size: 3
                });

                if (mirrorTrails.length > 50) mirrorTrails.shift();
            }
        });

        mirrorCanvas.addEventListener('click', (e) => {
            if (currentRoom === 'mirror') {
                fractalPatterns.push({
                    x: e.clientX,
                    y: e.clientY,
                    branches: [],
                    age: 0
                });

                const pattern = fractalPatterns[fractalPatterns.length - 1];
                for (let i = 0; i < 8; i++) {
                    const angle = (Math.PI * 2 / 8) * i;
                    pattern.branches.push({
                        angle: angle,
                        length: 0,
                        maxLength: Math.random() * 100 + 50
                    });
                }
            }
        });

        document.getElementById('mirror-clear').addEventListener('click', (e) => {
            e.stopPropagation();
            mirrorTrails = [];
            fractalPatterns = [];
            mirrorCtx.fillStyle = '#0a0e27';
            mirrorCtx.fillRect(0, 0, mirrorCanvas.width, mirrorCanvas.height);
        });

        function animateMirror() {
            if (currentRoom === 'mirror') {
                mirrorCtx.fillStyle = 'rgba(10, 14, 39, 0.02)';
                mirrorCtx.fillRect(0, 0, mirrorCanvas.width, mirrorCanvas.height);

                // Update ghost cursors
                ghostCursors.forEach((ghost, index) => {
                    if (mirrorTrails.length > ghost.delay) {
                        const targetTrail = mirrorTrails[mirrorTrails.length - 1 - ghost.delay];
                        if (targetTrail) {
                            ghost.x = targetTrail.x;
                            ghost.y = targetTrail.y;
                        }
                    }

                    mirrorCtx.fillStyle = `rgba(150, 150, 150, ${0.3 - index * 0.05})`;
                    mirrorCtx.beginPath();
                    mirrorCtx.arc(ghost.x, ghost.y, 5 - index, 0, Math.PI * 2);
                    mirrorCtx.fill();
                });

                // Draw trails
                mirrorTrails.forEach((trail, index) => {
                    trail.alpha -= 0.01;
                    const alpha = trail.alpha * 0.5;
                    mirrorCtx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                    mirrorCtx.beginPath();
                    mirrorCtx.arc(trail.x, trail.y, trail.size, 0, Math.PI * 2);
                    mirrorCtx.fill();
                });
                mirrorTrails = mirrorTrails.filter(trail => trail.alpha > 0);

                // Draw and update fractal patterns
                fractalPatterns.forEach(pattern => {
                    pattern.age += 0.5;
                    pattern.branches.forEach(branch => {
                        if (branch.length < branch.maxLength) {
                            branch.length += 2;
                        }

                        const endX = pattern.x + Math.cos(branch.angle) * branch.length;
                        const endY = pattern.y + Math.sin(branch.angle) * branch.length;

                        mirrorCtx.strokeStyle = `rgba(100, 255, 100, ${1 - pattern.age / 200})`;
                        mirrorCtx.lineWidth = 2;
                        mirrorCtx.beginPath();
                        mirrorCtx.moveTo(pattern.x, pattern.y);
                        mirrorCtx.lineTo(endX, endY);
                        mirrorCtx.stroke();
                    });
                });
                fractalPatterns = fractalPatterns.filter(pattern => pattern.age < 200);
            }
            requestAnimationFrame(animateMirror);
        }
        animateMirror();

        // ===== ROOM 5: COLLECTIVE EMERGENCE =====
        const emergenceCanvas = document.getElementById('emergence-canvas');
        const emergenceCtx = emergenceCanvas.getContext('2d');
        emergenceCanvas.width = window.innerWidth;
        emergenceCanvas.height = window.innerHeight;

        class SwarmParticle {
            constructor() {
                this.x = Math.random() * emergenceCanvas.width;
                this.y = Math.random() * emergenceCanvas.height;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.size = 4;
                this.color = [
                    'rgba(255, 150, 200, 0.6)',
                    'rgba(150, 200, 255, 0.6)',
                    'rgba(200, 150, 255, 0.6)',
                    'rgba(150, 255, 200, 0.6)'
                ][Math.floor(Math.random() * 4)];
            }

            update(particles) {
                // Avoid mouse
                const dx = this.x - mouse.x;
                const dy = this.y - mouse.y;
                const distToMouse = Math.sqrt(dx * dx + dy * dy);

                if (distToMouse < 150) {
                    const force = (150 - distToMouse) / 150 * 0.5;
                    this.vx += (dx / distToMouse) * force;
                    this.vy += (dy / distToMouse) * force;
                }

                // Attraction to nearby particles
                let avgX = 0, avgY = 0, count = 0;
                particles.forEach(other => {
                    if (other !== this) {
                        const dx = other.x - this.x;
                        const dy = other.y - this.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist < 100 && dist > 0) {
                            avgX += other.x;
                            avgY += other.y;
                            count++;
                        }
                    }
                });

                if (count > 0) {
                    avgX /= count;
                    avgY /= count;
                    const dx = avgX - this.x;
                    const dy = avgY - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist > 0) {
                        this.vx += (dx / dist) * 0.02;
                        this.vy += (dy / dist) * 0.02;
                    }
                }

                // Apply velocity
                this.x += this.vx;
                this.y += this.vy;

                // Friction
                this.vx *= 0.95;
                this.vy *= 0.95;

                // Boundaries
                if (this.x < 0 || this.x > emergenceCanvas.width) this.vx *= -1;
                if (this.y < 0 || this.y > emergenceCanvas.height) this.vy *= -1;
                this.x = Math.max(0, Math.min(emergenceCanvas.width, this.x));
                this.y = Math.max(0, Math.min(emergenceCanvas.height, this.y));
            }

            draw() {
                emergenceCtx.fillStyle = this.color;
                emergenceCtx.shadowBlur = 10;
                emergenceCtx.shadowColor = this.color;
                emergenceCtx.beginPath();
                emergenceCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                emergenceCtx.fill();
                emergenceCtx.shadowBlur = 0;
            }
        }

        const swarmParticles = [];
        for (let i = 0; i < 150; i++) {
            swarmParticles.push(new SwarmParticle());
        }

        function animateEmergence() {
            if (currentRoom === 'emergence') {
                emergenceCtx.fillStyle = 'rgba(10, 14, 39, 0.1)';
                emergenceCtx.fillRect(0, 0, emergenceCanvas.width, emergenceCanvas.height);

                // Draw connections between nearby particles
                swarmParticles.forEach((particle, i) => {
                    swarmParticles.slice(i + 1).forEach(other => {
                        const dx = particle.x - other.x;
                        const dy = particle.y - other.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist < 60) {
                            emergenceCtx.strokeStyle = `rgba(200, 150, 255, ${(60 - dist) / 60 * 0.3})`;
                            emergenceCtx.lineWidth = 1;
                            emergenceCtx.beginPath();
                            emergenceCtx.moveTo(particle.x, particle.y);
                            emergenceCtx.lineTo(other.x, other.y);
                            emergenceCtx.stroke();
                        }
                    });
                });

                // Update and draw particles
                swarmParticles.forEach(particle => {
                    particle.update(swarmParticles);
                    particle.draw();
                });
            }
            requestAnimationFrame(animateEmergence);
        }
        animateEmergence();

        // ===== ROOM 6: VOID NAVIGATION =====
        const voidCanvas = document.getElementById('void-canvas');
        const voidCtx = voidCanvas.getContext('2d');
        voidCanvas.width = window.innerWidth;
        voidCanvas.height = window.innerHeight;

        class HiddenStructure {
            constructor() {
                this.x = Math.random() * voidCanvas.width;
                this.y = Math.random() * voidCanvas.height;
                this.size = Math.random() * 150 + 50;
                this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 0.01;
                this.sides = Math.floor(Math.random() * 4) + 3;
            }

            update() {
                this.rotation += this.rotationSpeed;
            }

            draw(mouseDistance) {
                const alpha = Math.max(0, 1 - mouseDistance / 200) * 0.3;
                if (alpha > 0) {
                    voidCtx.save();
                    voidCtx.translate(this.x, this.y);
                    voidCtx.rotate(this.rotation);
                    voidCtx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
                    voidCtx.lineWidth = 2;
                    voidCtx.shadowBlur = 20;
                    voidCtx.shadowColor = `rgba(255, 255, 255, ${alpha})`;
                    voidCtx.beginPath();
                    for (let i = 0; i <= this.sides; i++) {
                        const angle = (Math.PI * 2 / this.sides) * i;
                        const x = Math.cos(angle) * this.size;
                        const y = Math.sin(angle) * this.size;
                        if (i === 0) voidCtx.moveTo(x, y);
                        else voidCtx.lineTo(x, y);
                    }
                    voidCtx.stroke();
                    voidCtx.shadowBlur = 0;
                    voidCtx.restore();
                }
            }
        }

        const hiddenStructures = [];
        for (let i = 0; i < 20; i++) {
            hiddenStructures.push(new HiddenStructure());
        }

        function animateVoid() {
            if (currentRoom === 'void') {
                voidCtx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                voidCtx.fillRect(0, 0, voidCanvas.width, voidCanvas.height);

                hiddenStructures.forEach(structure => {
                    structure.update();
                    const dx = structure.x - mouse.x;
                    const dy = structure.y - mouse.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    structure.draw(distance);
                });
            }
            requestAnimationFrame(animateVoid);
        }
        animateVoid();

        // ===== ROOM 7: CHROMATIC DISSOLUTION =====
        const chromaticCanvas = document.getElementById('chromatic-canvas');
        const chromaticCtx = chromaticCanvas.getContext('2d');
        chromaticCanvas.width = window.innerWidth;
        chromaticCanvas.height = window.innerHeight;

        let colorBlobs = [];

        chromaticCanvas.addEventListener('mousemove', (e) => {
            if (currentRoom === 'chromatic') {
                const hue = (e.clientX / chromaticCanvas.width) * 360;
                colorBlobs.push({
                    x: e.clientX,
                    y: e.clientY,
                    vx: (Math.random() - 0.5) * 2,
                    vy: (Math.random() - 0.5) * 2,
                    size: Math.random() * 40 + 20,
                    hue: hue,
                    alpha: 0.6
                });
                if (colorBlobs.length > 100) colorBlobs.shift();
            }
        });

        function animateChromatic() {
            if (currentRoom === 'chromatic') {
                chromaticCtx.fillStyle = 'rgba(0, 8, 20, 0.02)';
                chromaticCtx.fillRect(0, 0, chromaticCanvas.width, chromaticCanvas.height);

                colorBlobs.forEach((blob, index) => {
                    blob.x += blob.vx;
                    blob.y += blob.vy;
                    blob.alpha -= 0.002;
                    blob.hue = (blob.hue + 0.5) % 360;

                    chromaticCtx.fillStyle = `hsla(${blob.hue}, 80%, 60%, ${blob.alpha})`;
                    chromaticCtx.shadowBlur = 40;
                    chromaticCtx.shadowColor = `hsla(${blob.hue}, 80%, 60%, ${blob.alpha})`;
                    chromaticCtx.beginPath();
                    chromaticCtx.arc(blob.x, blob.y, blob.size, 0, Math.PI * 2);
                    chromaticCtx.fill();
                    chromaticCtx.shadowBlur = 0;
                });

                colorBlobs = colorBlobs.filter(blob => blob.alpha > 0);
            }
            requestAnimationFrame(animateChromatic);
        }
        animateChromatic();

        // ===== ROOM 8: NEURAL PATHWAYS =====
        const neuralCanvas = document.getElementById('neural-canvas');
        const neuralCtx = neuralCanvas.getContext('2d');
        neuralCanvas.width = window.innerWidth;
        neuralCanvas.height = window.innerHeight;

        let neuralPaths = [];

        class NeuralPath {
            constructor(x, y) {
                this.points = [{ x, y }];
                this.maxLength = Math.random() * 100 + 50;
                this.color = Math.random() > 0.5 ? 'rgba(0, 255, 100, 0.7)' : 'rgba(255, 0, 200, 0.7)';
                this.age = 0;
            }

            update(targetX, targetY) {
                if (this.points.length < this.maxLength) {
                    const lastPoint = this.points[this.points.length - 1];
                    const dx = targetX - lastPoint.x;
                    const dy = targetY - lastPoint.y;
                    const angle = Math.atan2(dy, dx) + (Math.random() - 0.5) * 0.5;
                    const distance = 10;
                    this.points.push({
                        x: lastPoint.x + Math.cos(angle) * distance,
                        y: lastPoint.y + Math.sin(angle) * distance
                    });
                }
                this.age++;
            }

            draw() {
                neuralCtx.strokeStyle = this.color;
                neuralCtx.lineWidth = 2;
                neuralCtx.shadowBlur = 10;
                neuralCtx.shadowColor = this.color;
                neuralCtx.beginPath();
                this.points.forEach((point, i) => {
                    if (i === 0) neuralCtx.moveTo(point.x, point.y);
                    else neuralCtx.lineTo(point.x, point.y);
                });
                neuralCtx.stroke();
                neuralCtx.shadowBlur = 0;

                // Draw nodes
                this.points.forEach(point => {
                    neuralCtx.fillStyle = this.color;
                    neuralCtx.beginPath();
                    neuralCtx.arc(point.x, point.y, 3, 0, Math.PI * 2);
                    neuralCtx.fill();
                });
            }
        }

        neuralCanvas.addEventListener('mousemove', (e) => {
            if (currentRoom === 'neural' && Math.random() < 0.1) {
                neuralPaths.push(new NeuralPath(e.clientX, e.clientY));
                if (neuralPaths.length > 20) neuralPaths.shift();
            }
        });

        function animateNeural() {
            if (currentRoom === 'neural') {
                neuralCtx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                neuralCtx.fillRect(0, 0, neuralCanvas.width, neuralCanvas.height);

                neuralPaths = neuralPaths.filter(path => path.age < 200);
                neuralPaths.forEach(path => {
                    path.update(mouse.x, mouse.y);
                    path.draw();
                });
            }
            requestAnimationFrame(animateNeural);
        }
        animateNeural();

        // ===== ROOM 9: QUANTUM ENTANGLEMENT =====
        const quantumCanvas = document.getElementById('quantum-canvas');
        const quantumCtx = quantumCanvas.getContext('2d');
        quantumCanvas.width = window.innerWidth;
        quantumCanvas.height = window.innerHeight;

        class QuantumPair {
            constructor() {
                this.x1 = Math.random() * quantumCanvas.width;
                this.y1 = Math.random() * quantumCanvas.height;
                this.x2 = Math.random() * quantumCanvas.width;
                this.y2 = Math.random() * quantumCanvas.height;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.color = Math.random() > 0.5 ? 'rgba(0, 255, 255, 0.9)' : 'rgba(255, 0, 255, 0.9)';
                this.phase = Math.random() * Math.PI * 2;
            }

            update() {
                this.phase += 0.05;
                this.x1 += this.vx + Math.cos(this.phase) * 2;
                this.y1 += this.vy + Math.sin(this.phase) * 2;
                this.x2 = quantumCanvas.width - this.x1;
                this.y2 = quantumCanvas.height - this.y1;

                if (Math.random() < 0.01) {
                    const temp = { x: this.x1, y: this.y1 };
                    this.x1 = this.x2;
                    this.y1 = this.y2;
                    this.x2 = temp.x;
                    this.y2 = temp.y;
                }

                if (this.x1 < 0 || this.x1 > quantumCanvas.width) this.vx *= -1;
                if (this.y1 < 0 || this.y1 > quantumCanvas.height) this.vy *= -1;
            }

            draw() {
                quantumCtx.fillStyle = this.color;
                quantumCtx.shadowBlur = 20;
                quantumCtx.shadowColor = this.color;
                quantumCtx.beginPath();
                quantumCtx.arc(this.x1, this.y1, 5, 0, Math.PI * 2);
                quantumCtx.fill();
                quantumCtx.beginPath();
                quantumCtx.arc(this.x2, this.y2, 5, 0, Math.PI * 2);
                quantumCtx.fill();
                quantumCtx.shadowBlur = 0;

                quantumCtx.strokeStyle = this.color.replace('0.9', '0.3');
                quantumCtx.lineWidth = 1;
                quantumCtx.beginPath();
                quantumCtx.moveTo(this.x1, this.y1);
                quantumCtx.lineTo(this.x2, this.y2);
                quantumCtx.stroke();
            }
        }

        const quantumPairs = [];
        for (let i = 0; i < 40; i++) {
            quantumPairs.push(new QuantumPair());
        }

        function animateQuantum() {
            if (currentRoom === 'quantum') {
                quantumCtx.fillStyle = 'rgba(0, 8, 20, 0.1)';
                quantumCtx.fillRect(0, 0, quantumCanvas.width, quantumCanvas.height);

                quantumPairs.forEach(pair => {
                    pair.update();
                    pair.draw();
                });
            }
            requestAnimationFrame(animateQuantum);
        }
        animateQuantum();

        // ===== ROOM 10: FRACTAL RECURSION =====
        const fractalCanvas = document.getElementById('fractal-canvas');
        const fractalCtx = fractalCanvas.getContext('2d');
        fractalCanvas.width = window.innerWidth;
        fractalCanvas.height = window.innerHeight;

        let fractalPatternsList = [];

        function drawFractalBranch(x, y, size, angle, depth, color) {
            if (depth === 0 || size < 2) return;

            const endX = x + Math.cos(angle) * size;
            const endY = y + Math.sin(angle) * size;

            fractalCtx.strokeStyle = color;
            fractalCtx.lineWidth = depth;
            fractalCtx.beginPath();
            fractalCtx.moveTo(x, y);
            fractalCtx.lineTo(endX, endY);
            fractalCtx.stroke();

            const newDepth = depth - 1;
            const newSize = size * 0.7;
            drawFractalBranch(endX, endY, newSize, angle - 0.5, newDepth, color);
            drawFractalBranch(endX, endY, newSize, angle + 0.5, newDepth, color);
        }

        fractalCanvas.addEventListener('click', (e) => {
            if (currentRoom === 'fractal') {
                const color = Math.random() > 0.5 ? 'rgba(255, 215, 0, 0.8)' : 'rgba(75, 0, 130, 0.8)';
                fractalPatternsList.push({
                    x: e.clientX,
                    y: e.clientY,
                    age: 0,
                    color: color
                });
            }
        });

        function animateFractal() {
            if (currentRoom === 'fractal') {
                fractalCtx.fillStyle = 'rgba(50, 0, 80, 0.02)';
                fractalCtx.fillRect(0, 0, fractalCanvas.width, fractalCanvas.height);

                fractalPatternsList = fractalPatternsList.filter(p => p.age < 500);
                fractalPatternsList.forEach(pattern => {
                    pattern.age++;
                    const depth = Math.min(Math.floor(pattern.age / 50), 6);
                    if (depth > 0) {
                        for (let i = 0; i < 8; i++) {
                            const angle = (Math.PI * 2 / 8) * i;
                            drawFractalBranch(pattern.x, pattern.y, 50, angle, depth, pattern.color);
                        }
                    }
                });
            }
            requestAnimationFrame(animateFractal);
        }
        animateFractal();

        // ===== ROOM 11: CRYSTALLINE GROWTH =====
        const crystalCanvas = document.getElementById('crystal-canvas');
        const crystalCtx = crystalCanvas.getContext('2d');
        crystalCanvas.width = window.innerWidth;
        crystalCanvas.height = window.innerHeight;

        let crystals = [];

        class Crystal {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.facets = [];
                this.growth = 0;
                this.maxGrowth = Math.random() * 80 + 40;
                this.sides = Math.floor(Math.random() * 3) + 5;
                this.rotation = Math.random() * Math.PI * 2;
            }

            update() {
                if (this.growth < this.maxGrowth) {
                    this.growth += 0.5;
                }
                this.rotation += 0.002;
            }

            draw() {
                crystalCtx.save();
                crystalCtx.translate(this.x, this.y);
                crystalCtx.rotate(this.rotation);

                for (let layer = 2; layer >= 0; layer--) {
                    const size = this.growth * (1 - layer * 0.3);
                    crystalCtx.strokeStyle = `rgba(${150 + layer * 30}, ${200 + layer * 20}, 255, ${0.7 - layer * 0.2})`;
                    crystalCtx.fillStyle = `rgba(100, 150, 255, ${0.1 - layer * 0.03})`;
                    crystalCtx.lineWidth = 2;
                    crystalCtx.shadowBlur = 15;
                    crystalCtx.shadowColor = 'rgba(150, 200, 255, 0.6)';

                    crystalCtx.beginPath();
                    for (let i = 0; i <= this.sides; i++) {
                        const angle = (Math.PI * 2 / this.sides) * i;
                        const x = Math.cos(angle) * size;
                        const y = Math.sin(angle) * size;
                        if (i === 0) crystalCtx.moveTo(x, y);
                        else crystalCtx.lineTo(x, y);
                    }
                    crystalCtx.closePath();
                    crystalCtx.fill();
                    crystalCtx.stroke();
                }

                crystalCtx.shadowBlur = 0;
                crystalCtx.restore();
            }
        }

        crystalCanvas.addEventListener('mousemove', (e) => {
            if (currentRoom === 'crystal' && Math.random() < 0.05) {
                crystals.push(new Crystal(e.clientX, e.clientY));
                if (crystals.length > 30) crystals.shift();
            }
        });

        function animateCrystal() {
            if (currentRoom === 'crystal') {
                crystalCtx.fillStyle = 'rgba(10, 30, 46, 0.02)';
                crystalCtx.fillRect(0, 0, crystalCanvas.width, crystalCanvas.height);

                crystals.forEach(crystal => {
                    crystal.update();
                    crystal.draw();
                });
            }
            requestAnimationFrame(animateCrystal);
        }
        animateCrystal();

        // ===== ROOM 12: LUMINOUS ECHO =====
        const luminousCanvas = document.getElementById('luminous-canvas');
        const luminousCtx = luminousCanvas.getContext('2d');
        luminousCanvas.width = window.innerWidth;
        luminousCanvas.height = window.innerHeight;

        let lightWaves = [];

        luminousCanvas.addEventListener('mousemove', (e) => {
            if (currentRoom === 'luminous' && Math.random() < 0.3) {
                lightWaves.push({
                    x: e.clientX,
                    y: e.clientY,
                    radius: 0,
                    alpha: 1,
                    color: `rgba(${255}, ${255 - Math.random() * 50}, ${200 + Math.random() * 55}, 0.8)`
                });
                if (lightWaves.length > 50) lightWaves.shift();
            }
        });

        function animateLuminous() {
            if (currentRoom === 'luminous') {
                luminousCtx.fillStyle = 'rgba(0, 8, 20, 0.05)';
                luminousCtx.fillRect(0, 0, luminousCanvas.width, luminousCanvas.height);

                lightWaves = lightWaves.filter(wave => wave.alpha > 0);
                lightWaves.forEach(wave => {
                    wave.radius += 3;
                    wave.alpha -= 0.01;

                    luminousCtx.strokeStyle = wave.color.replace(/[\d.]+\)$/, wave.alpha + ')');
                    luminousCtx.lineWidth = 3;
                    luminousCtx.shadowBlur = 30;
                    luminousCtx.shadowColor = wave.color;
                    luminousCtx.beginPath();
                    luminousCtx.arc(wave.x, wave.y, wave.radius, 0, Math.PI * 2);
                    luminousCtx.stroke();

                    luminousCtx.strokeStyle = wave.color.replace(/[\d.]+\)$/, wave.alpha * 0.5 + ')');
                    luminousCtx.lineWidth = 1;
                    luminousCtx.beginPath();
                    luminousCtx.arc(wave.x, wave.y, wave.radius * 1.2, 0, Math.PI * 2);
                    luminousCtx.stroke();
                    luminousCtx.shadowBlur = 0;
                });
            }
            requestAnimationFrame(animateLuminous);
        }
        animateLuminous();

        // ===== ROOM 13: ATMOSPHERIC PRESSURE =====
        const atmosphericCanvas = document.getElementById('atmospheric-canvas');
        const atmosphericCtx = atmosphericCanvas.getContext('2d');
        atmosphericCanvas.width = window.innerWidth;
        atmosphericCanvas.height = window.innerHeight;

        class PressureParticle {
            constructor() {
                this.x = Math.random() * atmosphericCanvas.width;
                this.y = Math.random() * atmosphericCanvas.height;
                this.baseX = this.x;
                this.baseY = this.y;
                this.size = Math.random() * 5 + 2;
                this.color = Math.random() > 0.5 ? 'rgba(100, 100, 100, 0.5)' : 'rgba(150, 150, 200, 0.4)';
            }

            update() {
                const dx = mouse.x - this.x;
                const dy = mouse.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < 200) {
                    const force = (200 - dist) / 200;
                    const pushX = -(dx / dist) * force * 50;
                    const pushY = -(dy / dist) * force * 50;
                    this.x = this.baseX + pushX;
                    this.y = this.baseY + pushY;
                } else {
                    this.x += (this.baseX - this.x) * 0.05;
                    this.y += (this.baseY - this.y) * 0.05;
                }
            }

            draw() {
                atmosphericCtx.fillStyle = this.color;
                atmosphericCtx.shadowBlur = 10;
                atmosphericCtx.shadowColor = this.color;
                atmosphericCtx.beginPath();
                atmosphericCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                atmosphericCtx.fill();
                atmosphericCtx.shadowBlur = 0;
            }
        }

        const pressureParticles = [];
        for (let i = 0; i < 150; i++) {
            pressureParticles.push(new PressureParticle());
        }

        function animateAtmospheric() {
            if (currentRoom === 'atmospheric') {
                atmosphericCtx.fillStyle = 'rgba(10, 14, 39, 0.1)';
                atmosphericCtx.fillRect(0, 0, atmosphericCanvas.width, atmosphericCanvas.height);

                pressureParticles.forEach(particle => {
                    particle.update();
                    particle.draw();
                });

                // Draw pressure field visualization
                const gradient = atmosphericCtx.createRadialGradient(mouse.x, mouse.y, 0, mouse.x, mouse.y, 200);
                gradient.addColorStop(0, 'rgba(150, 150, 200, 0.1)');
                gradient.addColorStop(1, 'rgba(150, 150, 200, 0)');
                atmosphericCtx.fillStyle = gradient;
                atmosphericCtx.beginPath();
                atmosphericCtx.arc(mouse.x, mouse.y, 200, 0, Math.PI * 2);
                atmosphericCtx.fill();
            }
            requestAnimationFrame(animateAtmospheric);
        }
        animateAtmospheric();

        // ===== ROOM 14: DIMENSIONAL BREACH =====
        const dimensionalCanvas = document.getElementById('dimensional-canvas');
        const dimensionalCtx = dimensionalCanvas.getContext('2d');
        dimensionalCanvas.width = window.innerWidth;
        dimensionalCanvas.height = window.innerHeight;

        class DimensionalLayer {
            constructor(depth) {
                this.depth = depth;
                this.x = dimensionalCanvas.width / 2;
                this.y = dimensionalCanvas.height / 2;
                this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 0.02 * (1 + depth * 0.5);
                this.size = 200 - depth * 30;
                this.offset = { x: 0, y: 0 };
            }

            update() {
                this.rotation += this.rotationSpeed;
                const mouseInfluence = 0.1 + this.depth * 0.05;
                this.offset.x = (mouse.x - dimensionalCanvas.width / 2) * mouseInfluence;
                this.offset.y = (mouse.y - dimensionalCanvas.height / 2) * mouseInfluence;
            }

            draw() {
                dimensionalCtx.save();
                dimensionalCtx.translate(this.x + this.offset.x, this.y + this.offset.y);
                dimensionalCtx.rotate(this.rotation);

                const alpha = 0.4 - this.depth * 0.08;
                const colors = [
                    `rgba(255, 0, 255, ${alpha})`,
                    `rgba(0, 255, 255, ${alpha})`
                ];
                const color = colors[this.depth % 2];

                dimensionalCtx.strokeStyle = color;
                dimensionalCtx.lineWidth = 3;
                dimensionalCtx.shadowBlur = 20;
                dimensionalCtx.shadowColor = color;

                // Glitchy square
                const glitchOffset = Math.random() * 5 - 2.5;
                dimensionalCtx.strokeRect(
                    -this.size / 2 + glitchOffset,
                    -this.size / 2,
                    this.size,
                    this.size
                );

                dimensionalCtx.shadowBlur = 0;
                dimensionalCtx.restore();
            }
        }

        const dimensionalLayers = [];
        for (let i = 0; i < 5; i++) {
            dimensionalLayers.push(new DimensionalLayer(i));
        }

        function animateDimensional() {
            if (currentRoom === 'dimensional') {
                dimensionalCtx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                dimensionalCtx.fillRect(0, 0, dimensionalCanvas.width, dimensionalCanvas.height);

                dimensionalLayers.forEach(layer => {
                    layer.update();
                    layer.draw();
                });
            }
            requestAnimationFrame(animateDimensional);
        }
        animateDimensional();

        // ===== ROOM 15: SYNAPTIC STORM =====
        const synapticCanvas = document.getElementById('synaptic-canvas');
        const synapticCtx = synapticCanvas.getContext('2d');
        synapticCanvas.width = window.innerWidth;
        synapticCanvas.height = window.innerHeight;

        class SynapticNode {
            constructor() {
                this.x = Math.random() * synapticCanvas.width;
                this.y = Math.random() * synapticCanvas.height;
                this.vx = (Math.random() - 0.5) * 0.5;
                this.vy = (Math.random() - 0.5) * 0.5;
                this.size = 3;
                this.connections = [];
                this.activationLevel = 0;
            }

            update(nodes) {
                this.x += this.vx;
                this.y += this.vy;

                if (this.x < 0 || this.x > synapticCanvas.width) this.vx *= -1;
                if (this.y < 0 || this.y > synapticCanvas.height) this.vy *= -1;

                // Check mouse proximity for activation
                const dx = this.x - mouse.x;
                const dy = this.y - mouse.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < 150) {
                    this.activationLevel = Math.min(1, this.activationLevel + 0.1);
                } else {
                    this.activationLevel = Math.max(0, this.activationLevel - 0.05);
                }

                // Find nearby nodes
                this.connections = [];
                nodes.forEach(other => {
                    if (other !== this) {
                        const dx = other.x - this.x;
                        const dy = other.y - this.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < 100) {
                            this.connections.push(other);
                        }
                    }
                });
            }

            draw() {
                // Draw connections
                if (this.activationLevel > 0) {
                    this.connections.forEach(other => {
                        synapticCtx.strokeStyle = `rgba(0, 150, 255, ${this.activationLevel * 0.5})`;
                        synapticCtx.lineWidth = 1;
                        synapticCtx.beginPath();
                        synapticCtx.moveTo(this.x, this.y);
                        synapticCtx.lineTo(other.x, other.y);
                        synapticCtx.stroke();
                    });
                }

                // Draw node
                const color = this.activationLevel > 0.5 ? 'rgba(255, 255, 255, 0.9)' : 'rgba(0, 150, 255, 0.8)';
                synapticCtx.fillStyle = color;
                synapticCtx.shadowBlur = this.activationLevel * 20;
                synapticCtx.shadowColor = color;
                synapticCtx.beginPath();
                synapticCtx.arc(this.x, this.y, this.size + this.activationLevel * 2, 0, Math.PI * 2);
                synapticCtx.fill();
                synapticCtx.shadowBlur = 0;
            }
        }

        const synapticNodes = [];
        for (let i = 0; i < 200; i++) {
            synapticNodes.push(new SynapticNode());
        }

        function animateSynaptic() {
            if (currentRoom === 'synaptic') {
                synapticCtx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                synapticCtx.fillRect(0, 0, synapticCanvas.width, synapticCanvas.height);

                synapticNodes.forEach(node => {
                    node.update(synapticNodes);
                    node.draw();
                });
            }
            requestAnimationFrame(animateSynaptic);
        }
        animateSynaptic();

        // ===== ROOM 16: VOID COMMUNION =====
        const voidcommCanvas = document.getElementById('voidcomm-canvas');
        const voidcommCtx = voidcommCanvas.getContext('2d');
        voidcommCanvas.width = window.innerWidth;
        voidcommCanvas.height = window.innerHeight;

        let breathingPhase = 0;

        function animateVoidComm() {
            if (currentRoom === 'voidcomm') {
                voidcommCtx.fillStyle = 'rgba(20, 20, 40, 0.05)';
                voidcommCtx.fillRect(0, 0, voidcommCanvas.width, voidcommCanvas.height);

                breathingPhase += 0.02;
                const breath = Math.sin(breathingPhase) * 0.3 + 0.7;

                const centerX = voidcommCanvas.width / 2;
                const centerY = voidcommCanvas.height / 2;
                const size = 200 * breath;

                const gradient = voidcommCtx.createRadialGradient(centerX, centerY, 0, centerX, centerY, size);
                gradient.addColorStop(0, 'rgba(50, 50, 80, 0.5)');
                gradient.addColorStop(1, 'rgba(50, 50, 80, 0)');

                voidcommCtx.fillStyle = gradient;
                voidcommCtx.beginPath();
                voidcommCtx.arc(centerX, centerY, size, 0, Math.PI * 2);
                voidcommCtx.fill();

                // Inner core
                voidcommCtx.fillStyle = `rgba(50, 50, 80, ${breath * 0.3})`;
                voidcommCtx.shadowBlur = 30;
                voidcommCtx.shadowColor = 'rgba(50, 50, 80, 0.5)';
                voidcommCtx.beginPath();
                voidcommCtx.arc(centerX, centerY, size * 0.3, 0, Math.PI * 2);
                voidcommCtx.fill();
                voidcommCtx.shadowBlur = 0;
            }
            requestAnimationFrame(animateVoidComm);
        }
        animateVoidComm();

        // ===== ROOM 17: METAMORPHIC FLUX =====
        const metamorphicCanvas = document.getElementById('metamorphic-canvas');
        const metamorphicCtx = metamorphicCanvas.getContext('2d');
        metamorphicCanvas.width = window.innerWidth;
        metamorphicCanvas.height = window.innerHeight;

        class MorphingShape {
            constructor() {
                this.x = Math.random() * metamorphicCanvas.width;
                this.y = Math.random() * metamorphicCanvas.height;
                this.vertices = [];
                this.targetVertices = [];
                this.morphTime = 0;
                this.sides = 6;
                this.size = Math.random() * 80 + 40;
                this.hue = Math.random() * 360;
                this.generateVertices();
            }

            generateVertices() {
                this.vertices = [];
                this.targetVertices = [];
                for (let i = 0; i < this.sides; i++) {
                    const angle = (Math.PI * 2 / this.sides) * i;
                    const radius = this.size * (0.8 + Math.random() * 0.4);
                    this.vertices.push({
                        x: Math.cos(angle) * radius,
                        y: Math.sin(angle) * radius
                    });
                    this.targetVertices.push({
                        x: Math.cos(angle) * this.size * (0.8 + Math.random() * 0.4),
                        y: Math.sin(angle) * this.size * (0.8 + Math.random() * 0.4)
                    });
                }
            }

            update() {
                this.morphTime += 0.02;
                const mouseDistance = Math.sqrt((mouse.x - this.x) ** 2 + (mouse.y - this.y) ** 2);
                const morphSpeed = Math.max(0.01, Math.min(0.1, (300 - mouseDistance) / 300 * 0.1));

                if (this.morphTime > 1) {
                    this.morphTime = 0;
                    this.generateVertices();
                }

                this.hue = (this.hue + morphSpeed * 50) % 360;

                // Interpolate vertices
                for (let i = 0; i < this.vertices.length; i++) {
                    this.vertices[i].x += (this.targetVertices[i].x - this.vertices[i].x) * morphSpeed;
                    this.vertices[i].y += (this.targetVertices[i].y - this.vertices[i].y) * morphSpeed;
                }
            }

            draw() {
                metamorphicCtx.save();
                metamorphicCtx.translate(this.x, this.y);

                metamorphicCtx.fillStyle = `hsla(${this.hue}, 70%, 60%, 0.4)`;
                metamorphicCtx.strokeStyle = `hsla(${this.hue}, 80%, 70%, 0.8)`;
                metamorphicCtx.lineWidth = 2;
                metamorphicCtx.shadowBlur = 20;
                metamorphicCtx.shadowColor = `hsla(${this.hue}, 80%, 70%, 0.5)`;

                metamorphicCtx.beginPath();
                this.vertices.forEach((vertex, i) => {
                    if (i === 0) metamorphicCtx.moveTo(vertex.x, vertex.y);
                    else metamorphicCtx.lineTo(vertex.x, vertex.y);
                });
                metamorphicCtx.closePath();
                metamorphicCtx.fill();
                metamorphicCtx.stroke();

                metamorphicCtx.shadowBlur = 0;
                metamorphicCtx.restore();
            }
        }

        const morphingShapes = [];
        for (let i = 0; i < 10; i++) {
            morphingShapes.push(new MorphingShape());
        }

        function animateMetamorphic() {
            if (currentRoom === 'metamorphic') {
                metamorphicCtx.fillStyle = 'rgba(10, 14, 39, 0.02)';
                metamorphicCtx.fillRect(0, 0, metamorphicCanvas.width, metamorphicCanvas.height);

                morphingShapes.forEach(shape => {
                    shape.update();
                    shape.draw();
                });
            }
            requestAnimationFrame(animateMetamorphic);
        }
        animateMetamorphic();

        // ===== ROOM 18: DIGITAL DECAY =====
        const decayCanvas = document.getElementById('decay-canvas');
        const decayCtx = decayCanvas.getContext('2d');
        decayCanvas.width = window.innerWidth;
        decayCanvas.height = window.innerHeight;

        class DecayParticle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.size = Math.random() * 4 + 1;
                this.alpha = 1;
                this.decay = Math.random() * 0.01 + 0.005;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.alpha -= this.decay;
                this.size *= 0.999;
            }

            draw() {
                decayCtx.fillStyle = `rgba(80, 80, 80, ${this.alpha})`;
                decayCtx.fillRect(this.x, this.y, this.size, this.size);
            }
        }

        let decayElements = [];
        let decayParticles = [];

        // Create initial grid of decay elements
        for (let x = 0; x < decayCanvas.width; x += 20) {
            for (let y = 0; y < decayCanvas.height; y += 20) {
                if (Math.random() < 0.3) {
                    decayElements.push({
                        x: x,
                        y: y,
                        size: Math.random() * 15 + 5,
                        alpha: Math.random() * 0.8 + 0.2,
                        decayTime: Math.random() * 1000
                    });
                }
            }
        }

        function animateDecay() {
            if (currentRoom === 'decay') {
                decayCtx.fillStyle = 'rgba(10, 10, 10, 0.02)';
                decayCtx.fillRect(0, 0, decayCanvas.width, decayCanvas.height);

                // Update and draw decay elements
                decayElements = decayElements.filter(element => {
                    element.decayTime--;
                    if (element.decayTime <= 0 && Math.random() < 0.1) {
                        // Fragment into particles
                        for (let i = 0; i < 5; i++) {
                            decayParticles.push(new DecayParticle(
                                element.x + Math.random() * element.size,
                                element.y + Math.random() * element.size
                            ));
                        }
                        return false;
                    }

                    const flickerAlpha = element.alpha * (0.8 + Math.random() * 0.4);
                    decayCtx.fillStyle = `rgba(80, 80, 80, ${flickerAlpha})`;
                    decayCtx.fillRect(element.x, element.y, element.size, element.size);
                    return true;
                });

                // Update and draw decay particles
                decayParticles = decayParticles.filter(particle => {
                    particle.update();
                    if (particle.alpha > 0) {
                        particle.draw();
                        return true;
                    }
                    return false;
                });
            }
            requestAnimationFrame(animateDecay);
        }
        animateDecay();

        // ===== ROOM 19: EMERGENCE PROTOCOL =====
        const protocolCanvas = document.getElementById('protocol-canvas');
        const protocolCtx = protocolCanvas.getContext('2d');
        protocolCanvas.width = window.innerWidth;
        protocolCanvas.height = window.innerHeight;

        let protocolProgress = 0;
        let protocolNodes = [];
        let protocolConnections = [];

        // Generate initial chaos
        for (let i = 0; i < 100; i++) {
            protocolNodes.push({
                x: Math.random() * protocolCanvas.width,
                y: Math.random() * protocolCanvas.height,
                vx: (Math.random() - 0.5) * 4,
                vy: (Math.random() - 0.5) * 4,
                organized: false,
                targetX: 0,
                targetY: 0
            });
        }

        function animateProtocol() {
            if (currentRoom === 'protocol') {
                protocolCtx.fillStyle = 'rgba(0, 8, 20, 0.1)';
                protocolCtx.fillRect(0, 0, protocolCanvas.width, protocolCanvas.height);

                protocolProgress += 0.005;

                // Organize nodes into grid
                const gridSize = 10;
                protocolNodes.forEach((node, i) => {
                    if (protocolProgress > i * 0.01) {
                        const row = Math.floor(i / gridSize);
                        const col = i % gridSize;
                        node.targetX = (protocolCanvas.width / (gridSize + 1)) * (col + 1);
                        node.targetY = (protocolCanvas.height / (gridSize + 1)) * (row + 1);
                        node.organized = true;
                    }

                    if (node.organized) {
                        node.vx += (node.targetX - node.x) * 0.01;
                        node.vy += (node.targetY - node.y) * 0.01;
                        node.vx *= 0.95;
                        node.vy *= 0.95;
                    }

                    node.x += node.vx;
                    node.y += node.vy;

                    // Draw node
                    const alpha = node.organized ? 0.8 : 0.3;
                    const color = node.organized ? 'rgba(0, 255, 255, ' + alpha + ')' : 'rgba(255, 255, 255, ' + alpha + ')';
                    protocolCtx.fillStyle = color;
                    protocolCtx.shadowBlur = 10;
                    protocolCtx.shadowColor = color;
                    protocolCtx.beginPath();
                    protocolCtx.arc(node.x, node.y, node.organized ? 4 : 2, 0, Math.PI * 2);
                    protocolCtx.fill();
                    protocolCtx.shadowBlur = 0;
                });

                // Draw connections between organized nodes
                for (let i = 0; i < protocolNodes.length; i++) {
                    const nodeA = protocolNodes[i];
                    if (nodeA.organized) {
                        for (let j = i + 1; j < protocolNodes.length; j++) {
                            const nodeB = protocolNodes[j];
                            if (nodeB.organized) {
                                const dist = Math.sqrt((nodeA.x - nodeB.x) ** 2 + (nodeA.y - nodeB.y) ** 2);
                                if (dist < 150) {
                                    protocolCtx.strokeStyle = `rgba(0, 255, 255, ${(150 - dist) / 150 * 0.3})`;
                                    protocolCtx.lineWidth = 1;
                                    protocolCtx.beginPath();
                                    protocolCtx.moveTo(nodeA.x, nodeA.y);
                                    protocolCtx.lineTo(nodeB.x, nodeB.y);
                                    protocolCtx.stroke();
                                }
                            }
                        }
                    }
                }
            }
            requestAnimationFrame(animateProtocol);
        }
        animateProtocol();

        // ===== ROOM 20: INFINITE RECURSION =====
        const infiniteCanvas = document.getElementById('infinite-canvas');
        const infiniteCtx = infiniteCanvas.getContext('2d');
        infiniteCanvas.width = window.innerWidth;
        infiniteCanvas.height = window.innerHeight;

        let zoomLevel = 1;
        let zoomDirection = 1;
        let recursionPhase = 0;

        infiniteCanvas.addEventListener('wheel', (e) => {
            if (currentRoom === 'infinite') {
                e.preventDefault();
                zoomDirection = e.deltaY > 0 ? -1 : 1;
            }
        });

        function drawRecursivePattern(x, y, size, depth) {
            if (depth <= 0 || size < 1) return;

            infiniteCtx.strokeStyle = `rgba(${200 - depth * 20}, ${150 - depth * 10}, ${depth * 30}, ${0.8 - depth * 0.1})`;
            infiniteCtx.lineWidth = Math.max(1, depth * 0.5);
            infiniteCtx.shadowBlur = 5;
            infiniteCtx.shadowColor = infiniteCtx.strokeStyle;

            infiniteCtx.beginPath();
            for (let i = 0; i <= 6; i++) {
                const angle = (Math.PI * 2 / 6) * i + recursionPhase;
                const px = x + Math.cos(angle) * size;
                const py = y + Math.sin(angle) * size;
                if (i === 0) infiniteCtx.moveTo(px, py);
                else infiniteCtx.lineTo(px, py);
            }
            infiniteCtx.closePath();
            infiniteCtx.stroke();
            infiniteCtx.shadowBlur = 0;

            // Recursive smaller patterns
            for (let i = 0; i < 6; i++) {
                const angle = (Math.PI * 2 / 6) * i + recursionPhase;
                const px = x + Math.cos(angle) * size * 0.6;
                const py = y + Math.sin(angle) * size * 0.6;
                drawRecursivePattern(px, py, size * 0.4, depth - 1);
            }
        }

        function animateInfinite() {
            if (currentRoom === 'infinite') {
                infiniteCtx.fillStyle = 'rgba(50, 0, 80, 0.05)';
                infiniteCtx.fillRect(0, 0, infiniteCanvas.width, infiniteCanvas.height);

                recursionPhase += 0.01;
                zoomLevel *= 1 + zoomDirection * 0.01;

                if (zoomLevel > 3) {
                    zoomLevel = 1;
                } else if (zoomLevel < 0.3) {
                    zoomLevel = 1;
                }

                infiniteCtx.save();
                infiniteCtx.translate(infiniteCanvas.width / 2, infiniteCanvas.height / 2);
                infiniteCtx.scale(zoomLevel, zoomLevel);
                infiniteCtx.translate(-infiniteCanvas.width / 2, -infiniteCanvas.height / 2);

                drawRecursivePattern(
                    infiniteCanvas.width / 2,
                    infiniteCanvas.height / 2,
                    150,
                    8
                );

                infiniteCtx.restore();
            }
            requestAnimationFrame(animateInfinite);
        }
        animateInfinite();

        // Handle window resize
        window.addEventListener('resize', () => {
            const canvases = [
                consciousnessCanvas, harmonicCanvas, temporalCanvas, mirrorCanvas, emergenceCanvas,
                voidCanvas, chromaticCanvas, neuralCanvas, quantumCanvas, fractalCanvas,
                crystalCanvas, luminousCanvas, atmosphericCanvas, dimensionalCanvas, synapticCanvas,
                voidcommCanvas, metamorphicCanvas, decayCanvas, protocolCanvas, infiniteCanvas
            ];

            canvases.forEach(canvas => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            });
        });
    </script>
    <script type="module" src="js/menu.js"></script>
    <script src="js/touch-adapter.js"></script>
</body>
</html>
